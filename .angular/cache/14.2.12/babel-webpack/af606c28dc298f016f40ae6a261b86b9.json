{"ast":null,"code":"// Experimental API below\n\n/**\n * get input values\n *\n * Extended by: Gabriel Schuster <github.com@actra.de>\n * Now gets values of inputs (including \"checked\" status radios, checkboxes), textareas and selects (including multiselects)\n * Tries to identify the elements as exact as possible, falls back to numeric index when identification fails\n * WIP refactor by: PatrickJS\n */\nexport function __getInputValues() {\n  const _inputs = document.querySelectorAll('input, textarea, select');\n\n  const inputs = Array.prototype.slice.call(_inputs);\n  return inputs.map(function (input) {\n    const inputTagName = input.tagName.toLowerCase();\n    const inputType = input.type;\n    const inputId = input.id && typeof input.id === 'string' ? input.id : null;\n    const inputName = input.name && typeof input.name === 'string' ? input.name : null;\n    const inputValue = input.value && typeof input.value === 'string' ? input.value : null;\n    const inputChildNodes = input.childNodes;\n    const inputSelected = Boolean(input.selected);\n    let elementStore = {\n      'tag': inputTagName,\n      'type': null,\n      'id': inputId,\n      'name': inputName,\n      'value': '',\n      'checked': false,\n      'options': []\n    };\n\n    if ('input' === inputTagName || 'textarea' === inputTagName) {\n      elementStore['type'] = inputType;\n\n      if ('input' !== inputTagName) {\n        elementStore['value'] = inputValue;\n        return elementStore;\n      }\n\n      switch (inputType) {\n        case 'checkbox':\n        case 'radio':\n          elementStore['checked'] = inputSelected;\n          elementStore['value'] = inputValue;\n          return elementStore;\n\n        case 'image':\n        case 'button':\n        case 'submit':\n        case 'reset':\n        default:\n          // These types don't need any config and thus need no update, they only were stored because they match \"input\"\n          return elementStore;\n      }\n    } else if ('select' === inputTagName) {\n      const childNodes = Array.prototype.slice.call(inputChildNodes);\n      const options = childNodes.map((option, i) => {\n        return {\n          value: option['value'],\n          selected: Boolean(option['selected'])\n        };\n      });\n      elementStore['options'] = options;\n      return elementStore;\n    }\n\n    return elementStore;\n  });\n}\n/**\n * set input values\n *\n * Extended by: Gabriel Schuster <github.com@actra.de>\n * WIP refactor by: PatrickJS\n */\n\nexport function __setInputValues($inputs) {\n  const inputs = document.querySelectorAll('input, textarea');\n  $inputs.forEach((store, i) => {\n    if ('input' === store.tag || 'textarea' === store.tag) {\n      if ('input' === store.tag && ('checkbox' === store.type || 'radio' === store.type)) {\n        let selector = 'input' + (null !== store.id ? '#' + store.id : '') + '[type=\"' + store.type + '\"]' + (null !== store.name ? '[name=\"' + store.name + '\"]' : '') + '[value=\"' + store.value + '\"]';\n        let element = document.body.querySelector(selector);\n\n        if (element && Boolean(store['checked'])) {\n          element['checked'] = 'checked';\n          element.dispatchEvent(new CustomEvent('input', {\n            detail: element['checked']\n          }));\n        }\n      } else if ('input' === store.tagName.toLowerCase() && ('image' === store.type || 'button' === store.type || 'submit' === store.type || 'reset' === store.type)) {// These types don't need any config and thus need no update, they only were stored because they match \"input\"\n      } else {\n        if (null === store.id && null === store.name) {\n          if (store.value.length && inputs[i] && inputs[i].tagName.toLowerCase() === store.tag && ('textarea' === store.tag || inputs[i].getAttribute('type') === store.type) && ('string' !== typeof inputs[i].id || !inputs[i].id.length) && ('string' !== typeof inputs[i].getAttribute('name') || !inputs[i].getAttribute('name').length)) {\n            inputs[i]['value'] = store.value;\n            inputs[i].dispatchEvent(new CustomEvent('input', {\n              detail: inputs[i]['value']\n            }));\n          }\n        } else {\n          let selector = 'input' + (null !== store.id ? '#' + store.id : '') + ('input' === store.tag ? '[type=\"' + store.type + '\"]' : '') + (null !== store.name ? '[name=\"' + store.name + '\"]' : '');\n          let element = document.body.querySelector(selector);\n\n          if (element && store.value.length) {\n            element['value'] = store.value;\n            element.dispatchEvent(new CustomEvent('input', {\n              detail: element['value']\n            }));\n          }\n        }\n      }\n    } else if ('select' === store.tag) {\n      let select = null;\n\n      if (null === store.id && null === store.name) {\n        if (inputs[i] && inputs[i].tagName.toLowerCase() === store.tag && ('string' !== typeof inputs[i].id || !inputs[i].id.length) && ('string' !== typeof inputs[i].getAttribute('name') || !inputs[i].getAttribute('name').length)) {\n          select = inputs[i];\n        }\n      } else {\n        let selector = 'select' + (null !== store.id ? '#' + store.id : '') + (null !== store.name ? '[name=\"' + store.name + '\"]' : '');\n        let element = document.body.querySelector(selector);\n\n        if (element) {\n          select = element;\n        }\n      }\n\n      if (select) {\n        store.options.forEach((storedOption, j) => {\n          let option = select.querySelector('option[value=\"' + storedOption.value + '\"]');\n\n          if (!option && select.childNodes[j] && ('string' !== typeof select.childNodes[j]['value'] || !select.childNodes[j]['value'].length)) {\n            option = select.childNodes[j];\n          }\n\n          if (option && !!storedOption.selected) {\n            option['selected'] = 'selected';\n            option.dispatchEvent(new CustomEvent('input', {\n              detail: option['selected']\n            }));\n          }\n        });\n      }\n    }\n  });\n}\nexport function __createInputTransfer() {\n  const $inputs = __getInputValues();\n\n  return function restoreInputValues() {\n    return __setInputValues($inputs);\n  };\n}","map":{"version":3,"names":["__getInputValues","_inputs","document","querySelectorAll","inputs","Array","prototype","slice","call","map","input","inputTagName","tagName","toLowerCase","inputType","type","inputId","id","inputName","name","inputValue","value","inputChildNodes","childNodes","inputSelected","Boolean","selected","elementStore","options","option","i","__setInputValues","$inputs","forEach","store","tag","selector","element","body","querySelector","dispatchEvent","CustomEvent","detail","length","getAttribute","select","storedOption","j","__createInputTransfer","restoreInputValues"],"sources":["D:/HMR/hmrDemo/node_modules/@angularclass/hmr/dist/experimental.js"],"sourcesContent":["// Experimental API below\n/**\n * get input values\n *\n * Extended by: Gabriel Schuster <github.com@actra.de>\n * Now gets values of inputs (including \"checked\" status radios, checkboxes), textareas and selects (including multiselects)\n * Tries to identify the elements as exact as possible, falls back to numeric index when identification fails\n * WIP refactor by: PatrickJS\n */\nexport function __getInputValues() {\n    const _inputs = document.querySelectorAll('input, textarea, select');\n    const inputs = Array.prototype.slice.call(_inputs);\n    return inputs.map(function (input) {\n        const inputTagName = input.tagName.toLowerCase();\n        const inputType = input.type;\n        const inputId = (input.id && typeof input.id === 'string') ? input.id : null;\n        const inputName = (input.name && typeof input.name === 'string') ? input.name : null;\n        const inputValue = (input.value && typeof input.value === 'string') ? input.value : null;\n        const inputChildNodes = input.childNodes;\n        const inputSelected = Boolean(input.selected);\n        let elementStore = {\n            'tag': inputTagName,\n            'type': null,\n            'id': inputId,\n            'name': inputName,\n            'value': '',\n            'checked': false,\n            'options': []\n        };\n        if ('input' === inputTagName || 'textarea' === inputTagName) {\n            elementStore['type'] = inputType;\n            if ('input' !== inputTagName) {\n                elementStore['value'] = inputValue;\n                return elementStore;\n            }\n            switch (inputType) {\n                case 'checkbox':\n                case 'radio':\n                    elementStore['checked'] = inputSelected;\n                    elementStore['value'] = inputValue;\n                    return elementStore;\n                case 'image':\n                case 'button':\n                case 'submit':\n                case 'reset':\n                default:\n                    // These types don't need any config and thus need no update, they only were stored because they match \"input\"\n                    return elementStore;\n            }\n        }\n        else if ('select' === inputTagName) {\n            const childNodes = Array.prototype.slice.call(inputChildNodes);\n            const options = childNodes.map((option, i) => {\n                return { value: option['value'], selected: Boolean(option['selected']) };\n            });\n            elementStore['options'] = options;\n            return elementStore;\n        }\n        return elementStore;\n    });\n}\n/**\n * set input values\n *\n * Extended by: Gabriel Schuster <github.com@actra.de>\n * WIP refactor by: PatrickJS\n */\nexport function __setInputValues($inputs) {\n    const inputs = document.querySelectorAll('input, textarea');\n    $inputs.forEach((store, i) => {\n        if ('input' === store.tag || 'textarea' === store.tag) {\n            if ('input' === store.tag && ('checkbox' === store.type || 'radio' === store.type)) {\n                let selector = 'input' + (null !== store.id ? '#' + store.id : '') + '[type=\"' + store.type + '\"]' + (null !== store.name ? '[name=\"' + store.name + '\"]' : '') +\n                    '[value=\"' + store.value + '\"]';\n                let element = document.body.querySelector(selector);\n                if (element && Boolean(store['checked'])) {\n                    element['checked'] = 'checked';\n                    element.dispatchEvent(new CustomEvent('input', { detail: element['checked'] }));\n                }\n            }\n            else if ('input' === store.tagName.toLowerCase() &&\n                ('image' === store.type || 'button' === store.type || 'submit' === store.type || 'reset' === store.type)) {\n                // These types don't need any config and thus need no update, they only were stored because they match \"input\"\n            }\n            else {\n                if (null === store.id && null === store.name) {\n                    if (store.value.length &&\n                        inputs[i] &&\n                        inputs[i].tagName.toLowerCase() === store.tag &&\n                        ('textarea' === store.tag || inputs[i].getAttribute('type') === store.type) &&\n                        ('string' !== typeof inputs[i].id || !inputs[i].id.length) &&\n                        ('string' !== typeof inputs[i].getAttribute('name') ||\n                            !inputs[i].getAttribute('name').length)) {\n                        inputs[i]['value'] = store.value;\n                        inputs[i].dispatchEvent(new CustomEvent('input', { detail: inputs[i]['value'] }));\n                    }\n                }\n                else {\n                    let selector = 'input' +\n                        (null !== store.id ? '#' + store.id : '') + ('input' === store.tag ? '[type=\"' + store.type + '\"]' : '') +\n                        (null !== store.name ? '[name=\"' + store.name + '\"]' : '');\n                    let element = document.body.querySelector(selector);\n                    if (element && store.value.length) {\n                        element['value'] = store.value;\n                        element.dispatchEvent(new CustomEvent('input', { detail: element['value'] }));\n                    }\n                }\n            }\n        }\n        else if ('select' === store.tag) {\n            let select = null;\n            if (null === store.id && null === store.name) {\n                if (inputs[i] && inputs[i].tagName.toLowerCase() === store.tag && ('string' !== typeof inputs[i].id || !inputs[i].id.length) &&\n                    ('string' !== typeof inputs[i].getAttribute('name') || !inputs[i].getAttribute('name').length)) {\n                    select = inputs[i];\n                }\n            }\n            else {\n                let selector = 'select' + (null !== store.id ? '#' + store.id : '') + (null !== store.name ? '[name=\"' + store.name + '\"]' : '');\n                let element = document.body.querySelector(selector);\n                if (element) {\n                    select = element;\n                }\n            }\n            if (select) {\n                store.options.forEach((storedOption, j) => {\n                    let option = select.querySelector('option[value=\"' + storedOption.value + '\"]');\n                    if (!option &&\n                        select.childNodes[j] &&\n                        ('string' !== typeof select.childNodes[j]['value'] || !select.childNodes[j]['value'].length)) {\n                        option = select.childNodes[j];\n                    }\n                    if (option && !!storedOption.selected) {\n                        option['selected'] = 'selected';\n                        option.dispatchEvent(new CustomEvent('input', { detail: option['selected'] }));\n                    }\n                });\n            }\n        }\n    });\n}\nexport function __createInputTransfer() {\n    const $inputs = __getInputValues();\n    return function restoreInputValues() {\n        return __setInputValues($inputs);\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}